#version 450
#extension GL_KHR_shader_subgroup_basic                  : enable
#extension GL_KHR_shader_subgroup_arithmetic             : enable
#extension GL_ARB_separate_shader_objects                : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

#include "pack.h"
#include "unpack.h"
#include "surfel.h"
#include "camera.h"
#include "random.h"
#include "colors.h"

// process based on a 16x16 tile
layout(local_size_x = SURFEL_TILE_X,
       local_size_y = SURFEL_TILE_Y,
       local_size_z = 1) in;

// info
layout(push_constant) uniform FrameInfo {
    uvec2 size; // resolution
    uint frameId;
} info;

// camera information
layout(set = 0, binding = 0) uniform Camera {
    mat4 invVP; // inverse(P * V) for world position reconstruction
    vec3 pos;
    float zNear;
    float zFar;
    float zFarRcp;
} camera;

// surfel information
layout(set = 1, binding = 0) buffer SurfelBuffer {
    Surfel data[];
} surfels;

// surfel metadata
layout(set = 1, binding = 1) buffer SurfelDataBuffer {
    SurfelData data[];
} surfelData;

// surfel grids
layout(set = 1, binding = 2) buffer SurfelGridBuffer {
    SurfelGrid data[];
} surfelGrids;

// surfel cell
layout(set = 1, binding = 3) buffer SurfelCellBuffer {
    uint data[];
} surfelCells;

// surfel stat
layout(set = 1, binding = 4) buffer SurfelStatBuffer {
    SurfelStat data;
} surfelStat;

// gbuffer
layout(set = 2, binding = 0)        uniform sampler2D  imageDepth;
layout(set = 2, binding = 1)        uniform sampler2D  imageNormal;
layout(set = 2, binding = 2)        uniform usampler2D imageObject;
layout(set = 2, binding = 3, r32f)  uniform image2D    imageSurfelCoverage;
layout(set = 2, binding = 4, rgba8) uniform image2D    imageSurfelCoverageDebug;

shared uint groupMinSurfelCount;

void main() {
    // initialize group shared memory
    if (gl_LocalInvocationIndex == 0) {
        groupMinSurfelCount = 0xffffffff;
    }
    memoryBarrierShared();

    // dimension check
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= info.size.x || pixel.y >= info.size.y) {
        return;
    }

    // calculate basic information
    float depth = texelFetch(imageDepth,  pixel, 0).x;
    uint primID = texelFetch(imageObject, pixel, 0).x;
    vec3 normal = texelFetch(imageNormal, pixel, 0).xyz;
    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(info.size);
    vec3 pos = reconstruct_position(uv, depth, camera.invVP);

    #if 0 // debug if world position reconstruction is correct
    vec4 color = vec4(pos, 1.0);
    imageStore(imageSurfelCoverageDebug, pixel, color);
    #endif

    // find grid for potential surfel on this pixel
    ivec3 surfel_grid = compute_surfel_grid(pos, camera.pos);
    if (!is_surfel_grid_valid(surfel_grid)) {
        // surfel grid out of range, early exit
        imageStore(imageSurfelCoverage, pixel, vec4(0.0));
        imageStore(imageSurfelCoverageDebug, pixel, vec4(0.0, 0.0, 0.0, 0.0));
        return;
    }

    #if 0 // debug which region survives grid calculation
    vec4 color = vec4(0.0, 1.0, 0.0, 1.0);
    imageStore(imageSurfelCoverageDebug, pixel, color);
    #endif

    // find the actual surfel grid for this pixel
    uint grid_index = compute_surfel_grid_index(surfel_grid);
    SurfelGrid cell = surfelGrids.data[grid_index];

    // apply surfel coverage
    float coverage = 0.0;
    vec4 color = vec4(0.0); // visualize color
    for (uint i = 0; i < cell.count; i++) {
        uint surfel_index = surfelCells.data[cell.offset + i];
        Surfel surfel = surfels.data[surfel_index];

        // check if this pixel is covered by this surfel (both distance and normal)
        vec3 L = surfel.position - pos;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;
        if (d2 < r2) {
            vec3 surfel_normal = unpack_unitvec3(surfel.normal) * 2.0 - 1.0;
            float dotN = dot(surfel_normal, normal);
            if (dotN > 0) {
                float dist = sqrt(d2);
                float contribution = 1.0;
                contribution *= clamp(dotN, 0.0, 1.0);
                contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);
                // TODO: compute contribution by surfel moment
                // surfel moment helps prevent incorrect color bleeding.
                contribution = smoothstep(0.0, 1.0, contribution);
                coverage += contribution;
                color += vec4(surfel.color, 1.0) * contribution;
            }
        }
        // end of pixel coverage check
    }

    if (color.a > 0) {
        color.rgb /= color.a;
        color.a = clamp(color.a, 0.0, 1.0);
    }

    #if 1
    uvec2 local_id = gl_LocalInvocationID.xy;
    if (cell.count < SURFEL_CELL_CAPACITY) {
        uint surfel_count_at_pixel = (uint(coverage) & 0xff) << 8
                                   | (local_id.x & 0xf) << 4
                                   | (local_id.y & 0xf) << 0;
        atomicMin(groupMinSurfelCount, surfel_count_at_pixel);
    }
    memoryBarrierShared();

    uint surfel_coverage = groupMinSurfelCount;
    uvec2 surfel_min_id = uvec2(
        (surfel_coverage >> 4) & 0xf,
        (surfel_coverage     ) & 0xf);
    if (local_id == surfel_min_id && coverage < SURFEL_TARGET_COVERAGE) {
        // need to spawn a new surfel
        float linear_depth = linearize_depth(depth, camera.zNear, camera.zFar) * camera.zFarRcp;
        float chance = 1.0 - pow(linear_depth, 8);
        chance = min(chance, 0.01);
        vec2 co = pos.xy + float(info.frameId);
        if (noise(co) < chance) {
            // allocate new surfel
            uint surfel_alloc = atomicAdd(surfelStat.data.count, 1);
            if (surfel_alloc < SURFEL_CAPACITY) {
                SurfelData surfel_data;
                surfel_data.position = pos;
                surfel_data.normal = pack_unitvec3(normal * 0.5 + 0.5);
                surfel_data.inconsistency = 1;
                // TODO: remove this later, this is only for visualization
                surfel_data.mean = random_colors[primID % random_color_count];
                surfelData.data[surfel_alloc] = surfel_data;
            }
        }
    }
    #else
    uvec2 local_id = gl_LocalInvocationID.xy;
    if (local_id.x == 0 && local_id.y == 0 && surfelStat.data.count == 0) {
        uint surfel_alloc = atomicAdd(surfelStat.data.count, 1);
        if (surfel_alloc == 0) {
            SurfelData surfel_data;

            const uint count = 100;
            for (uint i = 0; i < count; i++) {
                surfel_data.position = vec3(-0.5 * i, 0.0, 0.0);
                surfel_data.normal = pack_unitvec3(vec3(0.0, 1.0, 0.0));
                surfel_data.inconsistency = 1;
                surfel_data.mean = random_colors[primID % random_color_count];
                surfelData.data[i] = surfel_data;
            }

            surfelStat.data.count = count;
        }
    }
    #endif

    imageStore(imageSurfelCoverage, pixel, vec4(coverage));
    imageStore(imageSurfelCoverageDebug, pixel, color);
}
