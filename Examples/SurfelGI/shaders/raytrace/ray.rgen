#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "camera.h"
#include "unpack.h"
#include "random.h"
#include "sampling.h"
#include "transform.h"
#include "../common.h"

layout(push_constant) uniform Info {
    uint lightCount;
} info;

// acceleration structure
layout(set = 0, binding = SCENE_ACCEL_BINDING) uniform
accelerationStructureEXT sceneAS;

// frame information
layout(set = 0, binding = SCENE_FRAME_BINDING) uniform
Frame { FrameInfo data; } frame;

// camera information
layout(set = 0, binding = SCENE_CAMERA_BINDING) uniform
Camera { CameraInfo data; } camera;

// light information
layout(set = 0, binding = SCENE_LIGHT_BINDING) buffer
Light { LightInfo data[]; } lights;

// sky information
layout(set = 0, binding = SCENE_SKY_BINDING) buffer
Sky { SkyInfo data; } sky;

// surfel information
layout(set = 1, binding = SURFEL_BINDING) buffer
SurfelBuffer { Surfel data[]; } surfels;

layout(set = 1, binding = SURFEL_LIVE_BINDING) buffer
SurfelLiveBuffer { uint data[]; } surfelLive;

layout(set = 1, binding = SURFEL_DATA_BINDING) buffer
SurfelDataBuffer { SurfelData data[]; } surfelData;

layout(set = 1, binding = SURFEL_GRID_BINDING) buffer
SurfelGridBuffer { SurfelGridCell data[]; } surfelGrids;

layout(set = 1, binding = SURFEL_CELL_BINDING) buffer
SurfelCellBuffer { uint data[]; } surfelCells;

layout(set = 1, binding = SURFEL_STAT_BINDING) buffer
SurfelStatBuffer { SurfelStat data; } surfelStat;

// ray payload
layout(location = 0) rayPayloadEXT HitInfo hitData;
layout(location = 1) rayPayloadEXT bool    shadowed;

bool traceScene(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {
    traceRayEXT(sceneAS,          // acceleration structure
            gl_RayFlagsOpaqueEXT, // rayFlags
            0xff,                 // cullMask
            0,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            0,                    // missIndex
            rayOrigin,            // ray origin
            tMin,                 // ray min range
            rayDirection,         // ray direction
            tMax,                 // ray max range
            0);                   // payload (location = 0)
    return hitData.distance > 0.0;
}

bool traceShadow(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {
    traceRayEXT(sceneAS,          // acceleration structure
            gl_RayFlagsOpaqueEXT, // rayFlags
            0xff,                 // cullMask
            1,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            1,                    // missIndex
            rayOrigin,            // ray origin
            tMin,                 // ray min range
            rayDirection,         // ray direction
            tMax,                 // ray max range
            1);                   // payload (location = 1)
    return !shadowed;
}

void compute_directional_lighting(in LightInfo light,
                                  in HitInfo surface,
                                  out vec3 lightDirection,
                                  out vec3 lightDiffuse,
                                  out float NoL,
                                  out float dist) {
    lightDirection = -normalize(light.direction);
    NoL = dot(surface.normal, lightDirection);
    lightDiffuse = light.color * light.intensity;
    dist = HIGHP_FLT_MAX;
}

void compute_point_lighting(in LightInfo light,
                            in HitInfo surface,
                            out vec3 lightDirection,
                            out vec3 lightDiffuse,
                            out float NoL,
                            out float dist) {
    lightDirection = light.position - surface.position;
    float d2 = dot(lightDirection, lightDirection);
    float r2 = light.range * light.range;
    // check maximum range
    if (d2 < r2) {
        dist = sqrt(d2);
        lightDirection /= dist;
        // compute attenuation if needed
        NoL = dot(surface.normal, lightDirection);
        if (NoL > 0.0) {
            float att1 = clamp(1.0 - (d2 / r2), 0.0, 1.0);
            float att2 = att1 * att1;
            lightDiffuse = light.color * light.intensity * att2;
        }
    }
}

void compute_spot_lighting(in LightInfo light,
                           in HitInfo surface,
                           out vec3 lightDirection,
                           out vec3 lightDiffuse,
                           out float NoL,
                           out float dist) {
    lightDirection = light.position - surface.position;
    float d2 = dot(lightDirection, lightDirection);
    float r2 = light.range * light.range;
    // check maximum range
    if (d2 < r2) {
        dist = sqrt(d2);
        lightDirection /= dist;
        // compute attenuation if needed
        NoL = dot(surface.normal, lightDirection);
        if (NoL > 0.0) {
            float spotFactor = dot(lightDirection, light.direction);
            float spotCutOff = cos(light.angle);
            if (spotFactor > spotCutOff) {
                float att1 = clamp(1.0 - (d2 / r2), 0.0, 1.0);
                float att2 = att1 * att1;
                float attenuation = clamp(1.0 - (1.0 - spotFactor) * 1.0 / (1.0 - spotCutOff), 0.0, 1.0);
                lightDiffuse = light.color * light.intensity * att2;
            }
        }
    }
}

vec4 compute_surfel_lighting(in CameraInfo camera, in vec3 P, in vec3 N) {
    vec4 surfelGI = vec4(0.0);

    // fetch surfel grid
    int3 gridIndex = compute_surfel_grid(camera, P);
    uint cellIndex = compute_surfel_cell(gridIndex);
    SurfelGridCell cell = surfelGrids.data[cellIndex];

    // iterate through all surfels in this grid cell
    for (uint i = cell.offset; i < cell.offset + cell.count; i++) {
        uint cellIndex = surfelCells.data[i];
        Surfel surfel = surfels.data[cellIndex];

        // apply surfel coverage
        vec3 L = surfel.position - P;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;

        if (d2 < r2) {
            vec3 surfelN = unpack_unitvec3(surfel.normal) * 2.0 - 1.0;
            float dotN = dot(surfelN, N);
            if (dotN > 0) {
                float dist = sqrt(d2);
                float contribution = 1.0;
                contribution *= clamp(dotN, 0.0, 1.0);
                contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);
                // TODO: compute contribution by surfel moment
                // surfel moment helps prevent incorrect color bleeding.
                contribution = smoothstep(0.0, 1.0, contribution);
                surfelGI += vec4(surfel.color, 1.0) * contribution;
            }
        }
    }
    return surfelGI;
}

// This function is copied and modified from RayTracingGems 2019
void multiscale_mean_estimator(vec3 y, inout SurfelData data, float shortWindowBlend)
{
    vec3 mean = data.mean;
    vec3 shortMean = data.shortMean;
    vec3 variance = data.variance;
    float vbbr = data.vbbr;
    float inconsistency = data.inconsistency;

    // suppress fireflies
    {
        vec3 dev = sqrt(max(vec3(1.0e-5), variance));
        vec3 highThreshold = 0.1 + shortMean + dev * 8.0;
        vec3 overflow = max(vec3(0.0), y - highThreshold);
        y -= overflow;
    }

    vec3 delta = y - shortMean;
    shortMean = mix(shortMean, y, shortWindowBlend);
    vec3 delta2 = y - shortMean;

    // This should be a longer window than shortWindowBlend to avoid bias
    // from variance getting smaller when the short-term mean does
    float varianceBlend = shortWindowBlend * 0.5;
    variance = mix(variance, delta * delta2, varianceBlend);
    vec3 dev = sqrt(max(vec3(1e-5), variance));

    vec3 shortDiff = mean - shortMean;

    float relativeDiff = dot(vec3(0.299, 0.587, 0.114), abs(shortDiff) / max(vec3(1e-5), dev));
    inconsistency = mix(inconsistency, relativeDiff, 0.08);

    float varianceBasedBlendReduction = clamp(
        dot(vec3(0.299, 0.587, 0.114), 0.5 * shortMean / max(vec3(1e-5), dev)),
        1.0 / 32.0, 1.0);

    float catchUpBlend = clamp(smoothstep(0.0, 1.0,
        relativeDiff * max(0.02, inconsistency - 0.2)), 1.0 / 256.0, 1.0);
    catchUpBlend *= vbbr;

    vbbr = mix(vbbr, varianceBasedBlendReduction, 0.1);
    mean = mix(mean, y, clamp(catchUpBlend, 0.0, 1.0));

    // output
    data.mean = mean;
    data.vbbr = vbbr;
    data.variance = variance;
    data.inconsistency = inconsistency;
}

void main() {
    uint currentSurfelID = gl_LaunchIDEXT.x * SURFEL_CAPACITY_SQRT
                         + gl_LaunchIDEXT.y;

    // early exit
    if (currentSurfelID >= surfelStat.data.count) return;
    uint liveSurfelID = surfelLive.data[currentSurfelID];

    // frame info
    uint frameID = frame.data.frameID;

    // surfel data
    Surfel surfel = surfels.data[currentSurfelID];
    SurfelData data = surfelData.data[liveSurfelID];

    // surfel info
    float surfelR = surfel.radius;
    vec3  surfelP = surfel.position;
    vec3  surfelN = normalize(unpack_unitvec3(surfel.normal) * 2.0 - 1.0);

    // lighting result
    vec4 result = vec4(0.0);

    // rng
    RNGState rng = init_rng(gl_LaunchIDEXT.xy, ivec2(512, 512), frameID);

    // decide ray budget for this surfel
    int rayCount = max(16 - int(data.life), 1);

    // trace ray into scene
    for (int i = 0; i < rayCount; i++) {
        // ray origin
        // offset surfel position to avoid self intersection
        vec3 rayOrigin = surfelP + 0.00001 * surfelN;

        // ray direction
        // use cosine-weighted hemisphere sampling
        vec2 uv = vec2(rand(rng), rand(rng));
        vec3 rayDirection = to_tangent_space(cosine_sample_hemisphere(uv.x, uv.y), surfelN);

        // ray length
        float tMin = 0.00001;
        float tMax = 100000.0;

        // trace
        bool hit = traceScene(rayOrigin, rayDirection, tMin, tMax);
        if (!hit) {
            // TODO: update surfel moments with surfel radius

            // get sky color
            vec3 env = sky.data.color;
            result += vec4(env, 1.0);
        }
        else {
            // TODO: update surfel moments with surfel radius

            // record hit information
            HitInfo surface = hitData;

            // ray information at hit location
            rayOrigin = surface.position + surface.normal * 0.00001;

            // irradiance information
            vec3 hitResult = vec3(0.0);

            // light sampling
            for (uint i = 0; i < info.lightCount; i++) {
                LightInfo light = lights.data[i];

                // lighting info
                float NoL = 0.0;
                float dist = 0.0;
                vec3 lightDirection;
                vec3 lightDiffuse = vec3(0.0);

                switch (light.type) {
                    // compute direct point lighting
                    case LIGHT_TYPE_POINT:
                        compute_point_lighting(light, surface, lightDirection, lightDiffuse, NoL, dist);
                        break;
                    // compute direct spot lighting
                    case LIGHT_TYPE_SPOTLIGHT:
                        compute_spot_lighting(light, surface, lightDirection, lightDiffuse, NoL, dist);
                        break;
                    // compute direct directional lighting
                    case LIGHT_TYPE_DIRECTIONAL:
                        compute_directional_lighting(light, surface, lightDirection, lightDiffuse, NoL, dist);
                        break;
                }
                if (NoL > 0.0 && dist > 0.0) {
                    // check light occlusion
                    if (traceShadow(rayOrigin, rayDirection, tMin, dist)) {
                        hitResult += lightDiffuse / PI;
                    }
                }
            }

            // infinite bounces
            vec4 surfelGI = compute_surfel_lighting(camera.data, surface.position, surface.normal);
            if (surfelGI.a > 0.0) {
                surfelGI.rgb /= surfelGI.a;
                surfelGI.a = clamp(surfelGI.a, 0.0, 1.0);
                hitResult += surfelGI.rgb;
            }

            // adding to final result
            hitResult *= surface.albedo;
            hitResult += surface.emissive;
            result += vec4(hitResult, 1.0);
        }
        // end of scene ray trace
    }

    // surfel irradiance sharing
    vec4 surfelGI = compute_surfel_lighting(camera.data, surfelP, surfelN);
    if (surfelGI.a > 0.0) {
        surfelGI.rgb /= surfelGI.a;
        surfelGI.a = clamp(surfelGI.a, 0.0, 1.0);
        result += surfelGI;
    }

    // apply moving average integrator
    if (result.a > 0.0) {
        result /= result.a;
        multiscale_mean_estimator(result.rgb, data, 0.08);
    }

    // update surfel life
    data.life++;

    surfelData.data[liveSurfelID] = data;
}
