#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "camera.h"
#include "unpack.h"
#include "random.h"
#include "sampling.h"
#include "transform.h"
#include "../common.h"
#include "../halton.h"

const int2 locations_l1[9] = int2[9](
    int2(0, 0), int2(1, 0), int2(2, 0),
    int2(0, 1), int2(1, 1), int2(2, 1),
    int2(0, 2), int2(1, 2), int2(2, 2)
);

const int2 locations_l2[4] = int2[4](
    int2(0, 0), int2(1, 0),
    int2(0, 1), int2(1, 1)
);

layout(push_constant) uniform Info {
    uint lightCount;
} info;

// acceleration structure
layout(set = 0, binding = SCENE_ACCEL_BINDING) uniform
accelerationStructureEXT sceneAS;

// frame information
layout(set = 0, binding = SCENE_FRAME_BINDING) uniform
Frame { FrameInfo data; } frame;

// camera information
layout(set = 0, binding = SCENE_CAMERA_BINDING) uniform
Camera { CameraInfo data; } camera;

// light information
layout(set = 0, binding = SCENE_LIGHT_BINDING) buffer
Light { LightInfo data[]; } lights;

// sky information
layout(set = 0, binding = SCENE_SKY_BINDING) buffer
Sky { SkyInfo data; } sky;

// surfel information
layout(set = 1, binding = SURFEL_BINDING) buffer
SurfelBuffer { Surfel data[]; } surfels;

layout(set = 1, binding = SURFEL_LIVE_BINDING) buffer
SurfelLiveBuffer { uint data[]; } surfelLive;

layout(set = 1, binding = SURFEL_DATA_BINDING) buffer
SurfelDataBuffer { SurfelData data[]; } surfelData;

layout(set = 1, binding = SURFEL_GRID_BINDING) buffer
SurfelGridBuffer { SurfelGridCell data[]; } surfelGrids;

layout(set = 1, binding = SURFEL_CELL_BINDING) buffer
SurfelCellBuffer { uint data[]; } surfelCells;

layout(set = 1, binding = SURFEL_STAT_BINDING) buffer
SurfelStatBuffer { SurfelStat data; } surfelStat;

// surfel depth atlas texture
layout(set = 1, binding = SURFEL_DEPTH_BINDING, rg32f) uniform
image2D surfelDepth;

// surfel ray guiding texture
layout(set = 1, binding = SURFEL_RAYGUIDE_BINDING, r8) uniform
image2D surfelRayGuide;

// ray payload
layout(location = 0) rayPayloadEXT HitInfo hitData;
layout(location = 1) rayPayloadEXT bool    shadowed;

bool trace_scene(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {
    traceRayEXT(sceneAS,          // acceleration structure
            gl_RayFlagsOpaqueEXT, // rayFlags
            0xff,                 // cullMask
            0,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            0,                    // missIndex
            rayOrigin,            // ray origin
            tMin,                 // ray min range
            rayDirection,         // ray direction
            tMax,                 // ray max range
            0);                   // payload (location = 0)
    return hitData.distance > 0.0;
}

bool trace_shadow(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {
    const uint flags = gl_RayFlagsTerminateOnFirstHitEXT
                     | gl_RayFlagsSkipClosestHitShaderEXT
                     | gl_RayFlagsOpaqueEXT;
    shadowed = true;
    traceRayEXT(sceneAS,          // acceleration structure
            flags,                // rayFlags
            0xff,                 // cullMask
            0,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            1,                    // missIndex
            rayOrigin,            // ray origin
            tMin,                 // ray min range
            rayDirection,         // ray direction
            tMax,                 // ray max range
            1);                   // payload (location = 1)
    return shadowed;
}

vec2 linear_sample_radial_depth(vec2 pixel) {
    int2 base = int2(pixel / vec2(SURFEL_DEPTH_TEXELS)) * int2(SURFEL_DEPTH_TEXELS);
    vec2 tile = pixel - vec2(base) + vec2(0.5);
    int2 co = int2(tile);
    vec2 uv = fract(tile);

    int2 c0 = base + max(co - int2(1), int2(0));
    int2 c1 = base + min(co, int2(SURFEL_DEPTH_TEXELS - 1));
    vec4 p00 = imageLoad(surfelDepth, int2(c0.x, c0.y));
    vec4 p10 = imageLoad(surfelDepth, int2(c1.x, c0.y));
    vec4 p01 = imageLoad(surfelDepth, int2(c0.x, c1.y));
    vec4 p11 = imageLoad(surfelDepth, int2(c1.x, c1.y));
    return mix(mix(p00, p10, uv.x), mix(p01, p11, uv.x), uv.y).xy;
}

float load_rayguide_level1(int2 pixel, int2 pix) {
    return imageLoad(surfelRayGuide, pixel + pix * int2(2, 2) + int2(0, 0)).x
         + imageLoad(surfelRayGuide, pixel + pix * int2(2, 2) + int2(1, 0)).x
         + imageLoad(surfelRayGuide, pixel + pix * int2(2, 2) + int2(0, 1)).x
         + imageLoad(surfelRayGuide, pixel + pix * int2(2, 2) + int2(1, 1)).x;
}

vec3 sample_rayguide(uint surfelIndex, inout RNGState rng, out int2 loc, out float pdf) {
    float accum = 0.0;
    float target = rand(rng);
    int level1index = 0;
    int level2index = 0;

    int2 pixel = int2(unflatten_2d(surfelIndex, uint2(SURFEL_CAPACITY_SQRT)) * SURFEL_RAYGUIDE_TEXELS);

    // We are using 6x6 texels as discrete ray guiding function.
    // Level 1: walk 3x3 texels with linear sampler
    for (level1index = 0; level1index < 9; level1index++) {
        int2 location = locations_l1[level1index];
        float value = load_rayguide_level1(pixel, location);
        if ((accum + value) >= target) {
            break;
        }
        accum += value;
    }

    // Level 2: walk 6x6 texels with hierarchy
    int2 level2base = locations_l1[level1index] * 2;
    for (level2index = 0; level2index < 4; level2index++) {
        int2 location = level2base + locations_l2[level2index];
        float value = imageLoad(surfelRayGuide, location).x;
        if ((accum + value) >= target) {
            break;
        }
        accum += value;
    }

    int2 level2pix = level2base + locations_l2[level2index];
    vec2 uv = vec2(level2pix) / vec2(SURFEL_RAYGUIDE_TEXELS);
    uv.x += rand(rng) / 6.0;
    uv.y += rand(rng) / 6.0;

    loc = level2pix;
    pdf = imageLoad(surfelRayGuide, level2pix).x;
    return decode_hemioct(uv);
}

void normalize_rayguide(uint surfelIndex, inout SurfelData data) {
    int2 pixel = int2(unflatten_2d(surfelIndex, uint2(SURFEL_CAPACITY_SQRT)) * SURFEL_RAYGUIDE_TEXELS);

    float sum = 0.0;
    for (int y = 0; y < SURFEL_RAYGUIDE_TEXELS; y++) {
        for (int x = 0; x < SURFEL_RAYGUIDE_TEXELS; x++) {
            sum += imageLoad(surfelRayGuide, pixel + int2(x, y)).x * data.rayGuideScale;
        }
    }

    for (int y = 0; y < SURFEL_RAYGUIDE_TEXELS; y++) {
        for (int x = 0; x < SURFEL_RAYGUIDE_TEXELS; x++) {
            float value = imageLoad(surfelRayGuide, pixel + int2(x, y)).x / sum;
            imageStore(surfelRayGuide, pixel + int2(x, y), vec4(value, 0.0, 0.0, 1.0));
        }
    }

    data.rayGuideScale = sum;
}

vec3 compute_directional_lighting(in LightInfo light,
                                  in HitInfo surface,
                                  out float NoL,
                                  out float dist,
                                  out float radiance,
                                  out vec3 lightDirection) {
    dist = HIGHP_FLT_MAX;
    lightDirection = -normalize(light.direction);
    NoL = dot(surface.normal, lightDirection);
    radiance = light.intensity * max(0.0, NoL);
    return light.color * radiance;
}

vec3 compute_point_lighting(in LightInfo light,
                            in HitInfo surface,
                            out float NoL,
                            out float dist,
                            out float radiance,
                            out vec3 lightDirection) {
    lightDirection = light.position - surface.position;
    float d2 = dot(lightDirection, lightDirection);
    float r2 = light.range * light.range;
    // check maximum range
    if (d2 < r2) {
        dist = sqrt(d2);
        lightDirection /= dist;
        // compute attenuation if needed
        NoL = dot(surface.normal, lightDirection);
        if (NoL > 0.0) {
            float att1 = clamp(1.0 - (d2 / r2), 0.0, 1.0);
            float att2 = att1 * att1;
            radiance = light.intensity * att2;
            return light.color * radiance;
        }
    }
    return vec3(0.0);
}

vec3 compute_spot_lighting(in LightInfo light,
                           in HitInfo surface,
                           out float NoL,
                           out float dist,
                           out float radiance,
                           out vec3 lightDirection) {
    lightDirection = light.position - surface.position;
    float d2 = dot(lightDirection, lightDirection);
    float r2 = light.range * light.range;
    // check maximum range
    if (d2 < r2) {
        dist = sqrt(d2);
        lightDirection /= dist;
        // compute attenuation if needed
        NoL = dot(surface.normal, lightDirection);
        if (NoL > 0.0) {
            float spotFactor = dot(lightDirection, light.direction);
            float spotCutOff = cos(light.angle);
            if (spotFactor > spotCutOff) {
                float att1 = clamp(1.0 - (d2 / r2), 0.0, 1.0);
                float att2 = att1 * att1;
                float attenuation = clamp(1.0 - (1.0 - spotFactor) * 1.0 / (1.0 - spotCutOff), 0.0, 1.0);
                radiance = light.intensity * att2;
                return light.color * radiance;
            }
        }
    }
    return vec3(0.0);
}

vec4 compute_surfel_lighting(in CameraInfo camera, in vec3 P, in vec3 N) {
    vec4 surfelGI = vec4(0.0);

    // fetch surfel grid
    int3 gridIndex = compute_surfel_grid(camera, P);
    uint cellIndex = compute_surfel_cell(gridIndex);
    SurfelGridCell cell = surfelGrids.data[cellIndex];

    // iterate through all surfels in this grid cell
    for (uint i = cell.offset; i < cell.offset + cell.count; i++) {
        uint cellIndex = surfelCells.data[i];
        Surfel surfel = surfels.data[cellIndex];

        // apply surfel coverage
        vec3 L = surfel.position - P;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;

        if (d2 < r2) {
            vec3 surfelN = unpack_snorm3(surfel.normal);
            float dotN = dot(surfelN, N);
            if (dotN > 0.0) {
                float dist = sqrt(d2);
                float contribution = 1.0;
                contribution *= clamp(dotN, 0.0, 1.0);
                contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);

                float occlusion = 1.0;
                #ifdef ENABLE_SURFEL_RADIAL_DEPTH
                // radial depth function
                vec2 radialDepthPixel = compute_surfel_depth_pixel(cellIndex, -L/dist, surfelN);
                vec2 radialDepth = linear_sample_radial_depth(radialDepthPixel);
                occlusion *= compute_surfel_depth_weight(radialDepth, dist);
                #endif

                // surfel moment helps prevent incorrect color bleeding.
                contribution = smoothstep(0.0, 1.0, contribution);
                surfelGI += vec4(surfel.color * occlusion, 1.0) * contribution;
            }
        }
    }
    return surfelGI;
}

vec4 compute_irradiance_sharing(in CameraInfo camera, in vec3 P, in vec3 N, in vec3 variance) {
    vec4 surfelGI = vec4(0.0);

    // fetch surfel grid
    int3 gridIndex = compute_surfel_grid(camera, P);
    uint cellIndex = compute_surfel_cell(gridIndex);
    SurfelGridCell cell = surfelGrids.data[cellIndex];

    // iterate through all surfels in this grid cell
    for (uint i = cell.offset; i < cell.offset + cell.count; i++) {
        uint cellIndex = surfelCells.data[i];
        Surfel surfel = surfels.data[cellIndex];
        surfel.radius *= 2.0;

        // apply surfel coverage
        vec3 L = surfel.position - P;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;

        vec3 surfelN = unpack_snorm3(surfel.normal);
        float dotN = dot(surfelN, N);
        if (dotN > 0.0) {
            d2 = dot(L, L);
            float dist = sqrt(d2);

            float contribution = 1.0;
            contribution *= clamp(dotN, 0.0, 1.0);
            contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);

            float occlusion = 1.0;
            #ifdef ENABLE_SURFEL_RADIAL_DEPTH
            // radial depth function
            vec2 radialDepthPixel = compute_surfel_depth_pixel(cellIndex, -L/dist, surfelN);
            vec2 radialDepth = linear_sample_radial_depth(radialDepthPixel);
            occlusion *= compute_surfel_depth_weight(radialDepth, dist);
            #endif

            // surfel moment helps prevent incorrect color bleeding.
            contribution = smoothstep(0.0, 1.0, contribution);
            surfelGI += vec4(surfel.color * occlusion, 1.0) * contribution;
        }
    }
    return surfelGI;
}

// This function is copied and modified from RayTracingGems 2019
void multiscale_mean_estimator(vec3 y, inout SurfelData data, float shortWindowBlend)
{
    vec3 mean = data.mean;
    vec3 shortMean = data.shortMean;
    vec3 variance = data.variance;
    float vbbr = data.vbbr;
    float inconsistency = data.inconsistency;

    // suppress fireflies
    {
        vec3 dev = sqrt(max(vec3(1.0e-5), variance));
        vec3 highThreshold = 0.1 + shortMean + dev * 8.0;
        vec3 overflow = max(vec3(0.0), y - highThreshold);
        y -= overflow;
    }

    vec3 delta = y - shortMean;
    shortMean = mix(shortMean, y, shortWindowBlend);
    vec3 delta2 = y - shortMean;

    // This should be a longer window than shortWindowBlend to avoid bias
    // from variance getting smaller when the short-term mean does
    float varianceBlend = shortWindowBlend * 0.5;
    variance = mix(variance, delta * delta2, varianceBlend);
    vec3 dev = sqrt(max(vec3(1e-5), variance));

    vec3 shortDiff = mean - shortMean;

    float relativeDiff = dot(vec3(0.299, 0.587, 0.114), abs(shortDiff) / max(vec3(1e-5), dev));
    inconsistency = mix(inconsistency, relativeDiff, 0.08);

    float varianceBasedBlendReduction = clamp(
        dot(vec3(0.299, 0.587, 0.114), 0.5 * shortMean / max(vec3(1e-5), dev)),
        1.0 / 32.0, 1.0);

    float catchUpBlend = clamp(smoothstep(0.0, 1.0,
        relativeDiff * max(0.02, inconsistency - 0.2)), 1.0 / 256.0, 1.0);
    catchUpBlend *= vbbr;

    vbbr = mix(vbbr, varianceBasedBlendReduction, 0.1);
    mean = mix(mean, y, clamp(catchUpBlend, 0.0, 1.0));

    // output
    data.mean = mean;
    data.shortMean = shortMean;
    data.vbbr = vbbr;
    data.variance = variance;
    data.inconsistency = inconsistency;
}

void update_surfel_depth(uint2 pixel, float dist) {
    vec2 prev = imageLoad(surfelDepth, int2(pixel)).xy;
    float blend = prev.x < dist ? 0.005 : 0.5;
    vec2 next = mix(prev, vec2(dist, dist * dist), blend);
    imageStore(surfelDepth, int2(pixel), vec4(next, 0.0, 1.0));
}

void update_surfel_rayguide(uint2 pixel, float radiance) {
    float prev = imageLoad(surfelDepth, int2(pixel)).x;
    float blend = 0.5;
    float next = mix(prev, radiance, blend);
    imageStore(surfelRayGuide, int2(pixel), vec4(next, 0.0, 0.0, 1.0));
}

void main() {
    uint currentSurfelID = gl_LaunchIDEXT.x * SURFEL_CAPACITY_SQRT
                         + gl_LaunchIDEXT.y;

    // early exit
    if (currentSurfelID >= surfelStat.data.count) return;
    uint liveSurfelID = surfelLive.data[currentSurfelID];

    // frame info
    uint frameID = frame.data.frameID;

    // surfel data
    Surfel surfel = surfels.data[currentSurfelID];
    SurfelData data = surfelData.data[liveSurfelID];

    // surfel info
    float surfelR = surfel.radius;
    vec3  surfelP = surfel.position;
    vec3  surfelN = unpack_snorm3(surfel.normal);

    // lighting result
    vec4 result = vec4(0.0);

    // decide ray budget for this surfel
    #if 0
    int rayCount = int(ceil(mix(1, 16, data.inconsistency)));
    #else
    int rayCount = 1;
    #endif

    // rng
    RNGState rng = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, frameID);

    // trace ray into scene
    for (int i = 0; i < rayCount; i++) {
        float rnd1 = rand(rng);
        float rnd2 = rand(rng);

        float pdf = 1.0 / PI;
        float radiance = 0.0;

        // ray direction
        // use cosine-weighted hemisphere sampling
        vec2 uv = vec2(rnd1, rnd2);

        #ifdef ENABLE_SURFEL_RAY_GUIDING
        int2 rayGuidePixel;
        vec3 rayDirection = sample_rayguide(currentSurfelID, rng, rayGuidePixel, pdf);
        #else
        // rayDirZ is a randomly generated ray in hemisphere in +z axis
        // rayDirection is a world-space ray (rotated from rayDirZ)
        vec3 rayDirZ = cosine_sample_hemisphere(uv.x, uv.y);
        vec3 rayDirection = rotate_point(invert_rotation(compute_rotation_to_z_axis(surfelN)), rayDirZ);
        #endif

        // ray origin
        vec3 rayOrigin = surfelP;

        // ray length
        float tMin = 0.01;
        float tMax = 10000.0;

        #ifdef ENABLE_SURFEL_RADIAL_DEPTH
        // radial depth function
        uint2 radialDepthPixel = uint2(compute_surfel_depth_pixel(currentSurfelID, rayDirection, surfelN));
        #endif

        // trace
        bool hit = trace_scene(rayOrigin, rayDirection, tMin, tMax);
        if (!hit) {
            #ifdef ENABLE_SURFEL_RADIAL_DEPTH
            // update surfel moments with surfel radius
            update_surfel_depth(radialDepthPixel, surfel.radius * 2.0);
            #endif

            // get sky color
            vec3 env = sky.data.color;
            result += vec4(env, 1.0);
            radiance = 1.0;
        }
        else {
            #ifdef ENABLE_SURFEL_RADIAL_DEPTH
            // update surfel moments with surfel radius
            float hitDepth = hitData.distance * 0.9;
            hitDepth = clamp(hitDepth, 0.0, surfel.radius * 2.0);
            update_surfel_depth(radialDepthPixel, hitDepth);
            #endif

            // record hit information
            HitInfo surface;
            surface.position = hitData.position;
            surface.normal = hitData.normal;
            surface.albedo = hitData.albedo;
            surface.emissive = hitData.emissive;
            surface.distance = hitData.distance;

            // irradiance information
            vec3 hitResult = vec3(0.0);

            // light sampling
            for (uint i = 0; i < info.lightCount; i++) {
                LightInfo light = lights.data[i];

                // lighting info
                float NoL = -1.0;
                float dist = -1.0;
                vec3 lightDiffuse = vec3(0.0);
                vec3 lightDirection = vec3(0.0);

                switch (light.type) {
                    // compute direct point lighting
                    case LIGHT_TYPE_POINT:
                        lightDiffuse = compute_point_lighting(light, surface, NoL, dist, radiance, lightDirection);
                        break;
                    // compute direct spot lighting
                    case LIGHT_TYPE_SPOTLIGHT:
                        lightDiffuse = compute_spot_lighting(light, surface, NoL, dist, radiance, lightDirection);
                        break;
                    // compute direct directional lighting
                    case LIGHT_TYPE_DIRECTIONAL:
                        lightDiffuse = compute_directional_lighting(light, surface, NoL, dist, radiance, lightDirection);
                        break;
                }

                // add light contribution
                if (NoL > 0.0 && dist > 0.0) {
                    // ray information at hit location
                    rayDirection = lightDirection;
                    rayOrigin = surface.position;

                    // check occlusion
                    if (!trace_shadow(rayOrigin, rayDirection, tMin, dist)) {
                        hitResult += lightDiffuse * pdf;
                        radiance = 0.0;
                    }
                } else {
                    radiance = 0.0;
                }
            }

            // update ray guiding function
            #ifdef ENABLE_SURFEL_RAY_GUIDING
            update_surfel_rayguide(rayGuidePixel, radiance);
            normalize_rayguide(currentSurfelID, data);
            #endif

            // infinite bounces
            #ifdef ENABLE_INFINITE_BOUNCES
            vec4 surfelGI = compute_surfel_lighting(camera.data, surface.position, surface.normal);
            if (surfelGI.a > 0.0) {
                surfelGI.rgb /= surfelGI.a;
                surfelGI.a = clamp(surfelGI.a, 0.0, 1.0);
                hitResult += surfelGI.rgb;
            }
            #endif

            // adding to final result
            hitResult *= surface.albedo;
            hitResult += surface.emissive;
            result += vec4(hitResult, 1.0);
        }
        // end of scene ray trace
    }

    // surfel irradiance sharing
    #ifdef ENABLE_IRRADIANCE_SHARING
    vec4 surfelGI = compute_irradiance_sharing(camera.data, surfelP, surfelN, data.variance);
    if (surfelGI.a > 0.0) {
        surfelGI.rgb /= surfelGI.a;
        surfelGI.a = clamp(surfelGI.a, 0.0, 1.0);
        result += surfelGI;
    }
    #endif

    // apply moving average integrator
    if (result.a > 0.0) {
        result /= result.a;
        multiscale_mean_estimator(result.rgb, data, 0.08);
    }

    // update surfel life
    data.life++;

    surfelData.data[liveSurfelID] = data;
}
