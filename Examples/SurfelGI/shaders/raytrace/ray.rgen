#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "camera.h"
#include "unpack.h"
#include "random.h"
#include "sampling.h"
#include "transform.h"
#include "../common.h"
#include "../halton.h"

layout(push_constant) uniform Info {
    uint lightCount;
} info;

// acceleration structure
layout(set = 0, binding = SCENE_ACCEL_BINDING) uniform
accelerationStructureEXT sceneAS;

// frame information
layout(set = 0, binding = SCENE_FRAME_BINDING) uniform
Frame { FrameInfo data; } frame;

// camera information
layout(set = 0, binding = SCENE_CAMERA_BINDING) uniform
Camera { CameraInfo data; } camera;

// light information
layout(set = 0, binding = SCENE_LIGHT_BINDING) buffer
Light { LightInfo data[]; } lights;

// sky information
layout(set = 0, binding = SCENE_SKY_BINDING) buffer
Sky { SkyInfo data; } sky;

// surfel information
layout(set = 1, binding = SURFEL_BINDING) buffer
SurfelBuffer { Surfel data[]; } surfels;

layout(set = 1, binding = SURFEL_LIVE_BINDING) buffer
SurfelLiveBuffer { uint data[]; } surfelLive;

layout(set = 1, binding = SURFEL_DATA_BINDING) buffer
SurfelDataBuffer { SurfelData data[]; } surfelData;

layout(set = 1, binding = SURFEL_GRID_BINDING) buffer
SurfelGridBuffer { SurfelGridCell data[]; } surfelGrids;

layout(set = 1, binding = SURFEL_CELL_BINDING) buffer
SurfelCellBuffer { uint data[]; } surfelCells;

layout(set = 1, binding = SURFEL_STAT_BINDING) buffer
SurfelStatBuffer { SurfelStat data; } surfelStat;

// surfel depth atlas texture
layout(set = 1, binding = SURFEL_DEPTH_BINDING, rg32f) uniform
image2D surfelDepth;

// ray payload
layout(location = 0) rayPayloadEXT HitInfo hitData;
layout(location = 1) rayPayloadEXT bool    shadowed;

bool traceScene(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {
    traceRayEXT(sceneAS,          // acceleration structure
            gl_RayFlagsOpaqueEXT, // rayFlags
            0xff,                 // cullMask
            0,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            0,                    // missIndex
            rayOrigin,            // ray origin
            tMin,                 // ray min range
            rayDirection,         // ray direction
            tMax,                 // ray max range
            0);                   // payload (location = 0)
    return hitData.distance > 0.0;
}

bool traceShadow(vec3 rayOrigin, vec3 rayDirection, float tMin, float tMax) {
    const uint flags = gl_RayFlagsTerminateOnFirstHitEXT
                     | gl_RayFlagsSkipClosestHitShaderEXT
                     | gl_RayFlagsOpaqueEXT;
    traceRayEXT(sceneAS,          // acceleration structure
            flags,                // rayFlags
            0xff,                 // cullMask
            0,                    // sbtRecordOffset
            0,                    // sbtRecordStride
            1,                    // missIndex
            rayOrigin,            // ray origin
            tMin,                 // ray min range
            rayDirection,         // ray direction
            tMax,                 // ray max range
            1);                   // payload (location = 1)
    return !shadowed;
}

vec3 compute_directional_lighting(in LightInfo light,
                                  in HitInfo surface,
                                  out float NoL,
                                  out float dist) {
    dist = HIGHP_FLT_MAX;
    vec3 lightDirection = -normalize(light.direction);
    NoL = dot(surface.normal, lightDirection);
    return light.color * light.intensity * max(0.0, NoL);
}

vec3 compute_point_lighting(in LightInfo light,
                            in HitInfo surface,
                            out float NoL,
                            out float dist) {
    vec3 lightDirection = light.position - surface.position;
    float d2 = dot(lightDirection, lightDirection);
    float r2 = light.range * light.range;
    // check maximum range
    if (d2 < r2) {
        dist = sqrt(d2);
        lightDirection /= dist;
        // compute attenuation if needed
        NoL = dot(surface.normal, lightDirection);
        if (NoL > 0.0) {
            float att1 = clamp(1.0 - (d2 / r2), 0.0, 1.0);
            float att2 = att1 * att1;
            return light.color * light.intensity * att2;
        }
    }
    return vec3(0.0);
}

vec3 compute_spot_lighting(in LightInfo light,
                           in HitInfo surface,
                           out float NoL,
                           out float dist) {
    vec3 lightDirection = light.position - surface.position;
    float d2 = dot(lightDirection, lightDirection);
    float r2 = light.range * light.range;
    // check maximum range
    if (d2 < r2) {
        dist = sqrt(d2);
        lightDirection /= dist;
        // compute attenuation if needed
        NoL = dot(surface.normal, lightDirection);
        if (NoL > 0.0) {
            float spotFactor = dot(lightDirection, light.direction);
            float spotCutOff = cos(light.angle);
            if (spotFactor > spotCutOff) {
                float att1 = clamp(1.0 - (d2 / r2), 0.0, 1.0);
                float att2 = att1 * att1;
                float attenuation = clamp(1.0 - (1.0 - spotFactor) * 1.0 / (1.0 - spotCutOff), 0.0, 1.0);
                return light.color * light.intensity * att2;
            }
        }
    }
    return vec3(0.0);
}

vec4 compute_surfel_lighting(in CameraInfo camera, in vec3 P, in vec3 N) {
    vec4 surfelGI = vec4(0.0);

    // fetch surfel grid
    int3 gridIndex = compute_surfel_grid(camera, P);
    uint cellIndex = compute_surfel_cell(gridIndex);
    SurfelGridCell cell = surfelGrids.data[cellIndex];

    // iterate through all surfels in this grid cell
    for (uint i = cell.offset; i < cell.offset + cell.count; i++) {
        uint cellIndex = surfelCells.data[i];
        Surfel surfel = surfels.data[cellIndex];

        // apply surfel coverage
        vec3 L = surfel.position - P;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;

        if (d2 < r2) {
            vec3 surfelN = unpack_unitvec3(surfel.normal) * 2.0 - 1.0;
            float dotN = dot(surfelN, N);
            if (dotN > 0) {
                float dist = sqrt(d2);
                float contribution = 1.0;
                contribution *= clamp(dotN, 0.0, 1.0);
                contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);

                #ifdef ENABLE_SURFEL_RADIAL_DEPTH
                // radial depth function
                uint2 radialDepthPixel = uint2(compute_surfel_octmap_pixel(cellIndex, L/dist, SURFEL_DEPTH_TEXELS));
                vec2 radialDepth = imageLoad(surfelDepth, int2(radialDepthPixel)).xy;
                contribution *= compute_surfel_radial_depth(radialDepth, dist);
                #endif

                // surfel moment helps prevent incorrect color bleeding.
                contribution = smoothstep(0.0, 1.0, contribution);
                surfelGI += vec4(surfel.color, 1.0) * contribution;
            }
        }
    }
    return surfelGI;
}

vec4 compute_irradiance_sharing(in CameraInfo camera, in vec3 P, in vec3 N, in vec3 variance) {
    vec4 surfelGI = vec4(0.0);

    // fetch surfel grid
    int3 gridIndex = compute_surfel_grid(camera, P);
    uint cellIndex = compute_surfel_cell(gridIndex);
    SurfelGridCell cell = surfelGrids.data[cellIndex];

    // iterate through all surfels in this grid cell
    for (uint i = cell.offset; i < cell.offset + cell.count; i++) {
        uint cellIndex = surfelCells.data[i];
        Surfel surfel = surfels.data[cellIndex];

        // apply surfel coverage
        vec3 L = surfel.position - P;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;

        vec3 surfelN = unpack_unitvec3(surfel.normal) * 2.0 - 1.0;
        float dotN = dot(surfelN, N);
        if (dotN > 0) {
            vec3 var = normalize(variance);
            mat3 cov = outerProduct(var, var);
            L = cov * L;
            d2 = dot(L, L);
            float dist = sqrt(d2);

            float contribution = 1.0;
            contribution *= clamp(dotN, 0.0, 1.0);
            contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);

            #ifdef ENABLE_SURFEL_RADIAL_DEPTH
            // radial depth function
            uint2 radialDepthPixel = uint2(compute_surfel_octmap_pixel(cellIndex, L/dist, SURFEL_DEPTH_TEXELS));
            vec2 radialDepth = imageLoad(surfelDepth, int2(radialDepthPixel)).xy;
            contribution *= compute_surfel_radial_depth(radialDepth, dist);
            #endif

            // surfel moment helps prevent incorrect color bleeding.
            contribution = smoothstep(0.0, 1.0, contribution);
            surfelGI += vec4(surfel.color, 1.0) * contribution;
        }
    }
    return surfelGI;
}

// This function is copied and modified from RayTracingGems 2019
void multiscale_mean_estimator(vec3 y, inout SurfelData data, float shortWindowBlend)
{
    vec3 mean = data.mean;
    vec3 shortMean = data.shortMean;
    vec3 variance = data.variance;
    float vbbr = data.vbbr;
    float inconsistency = data.inconsistency;

    // suppress fireflies
    {
        vec3 dev = sqrt(max(vec3(1.0e-5), variance));
        vec3 highThreshold = 0.1 + shortMean + dev * 8.0;
        vec3 overflow = max(vec3(0.0), y - highThreshold);
        y -= overflow;
    }

    vec3 delta = y - shortMean;
    shortMean = mix(shortMean, y, shortWindowBlend);
    vec3 delta2 = y - shortMean;

    // This should be a longer window than shortWindowBlend to avoid bias
    // from variance getting smaller when the short-term mean does
    float varianceBlend = shortWindowBlend * 0.5;
    variance = mix(variance, delta * delta2, varianceBlend);
    vec3 dev = sqrt(max(vec3(1e-5), variance));

    vec3 shortDiff = mean - shortMean;

    float relativeDiff = dot(vec3(0.299, 0.587, 0.114), abs(shortDiff) / max(vec3(1e-5), dev));
    inconsistency = mix(inconsistency, relativeDiff, 0.08);

    float varianceBasedBlendReduction = clamp(
        dot(vec3(0.299, 0.587, 0.114), 0.5 * shortMean / max(vec3(1e-5), dev)),
        1.0 / 32.0, 1.0);

    float catchUpBlend = clamp(smoothstep(0.0, 1.0,
        relativeDiff * max(0.02, inconsistency - 0.2)), 1.0 / 256.0, 1.0);
    catchUpBlend *= vbbr;

    vbbr = mix(vbbr, varianceBasedBlendReduction, 0.1);
    mean = mix(mean, y, clamp(catchUpBlend, 0.0, 1.0));

    // output
    data.mean = mean;
    data.shortMean = shortMean;
    data.vbbr = vbbr;
    data.variance = variance;
    data.inconsistency = inconsistency;
}

void update_surfel_depth(uint2 pixel, float dist) {
    vec2 prev = imageLoad(surfelDepth, int2(pixel)).xy;
    float blend = prev.x < dist ? 0.005 : 0.5;
    vec2 next = mix(prev, vec2(dist, dist * dist), blend);
    imageStore(surfelDepth, int2(pixel), vec4(next, 0.0, 1.0));
}

void main() {
    uint currentSurfelID = gl_LaunchIDEXT.x * SURFEL_CAPACITY_SQRT
                         + gl_LaunchIDEXT.y;

    // early exit
    if (currentSurfelID >= surfelStat.data.count) return;
    uint liveSurfelID = surfelLive.data[currentSurfelID];

    // frame info
    uint frameID = frame.data.frameID;

    // surfel data
    Surfel surfel = surfels.data[currentSurfelID];
    SurfelData data = surfelData.data[liveSurfelID];

    // surfel info
    float surfelR = surfel.radius;
    vec3  surfelP = surfel.position;
    vec3  surfelN = normalize(unpack_unitvec3(surfel.normal) * 2.0 - 1.0);

    // lighting result
    vec4 result = vec4(0.0);

    // decide ray budget for this surfel
    int rayCount = int(ceil(mix(1, 16, data.inconsistency)));

    // rng
    RNGState rng = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy, frameID);
    HaltonState halton = halton_init(int(gl_LaunchIDEXT.x), int(gl_LaunchIDEXT.y), 0, rayCount, int(frameID), 1);

    // trace ray into scene
    for (int i = 0; i < rayCount; i++) {
        // ray origin
        // offset surfel position to avoid self intersection
        vec3 rayOrigin = surfelP + 0.01 * surfelN;

        float rnd1 = fract(halton_next(halton) + rand(rng));
        float rnd2 = fract(halton_next(halton) + rand(rng));

        // ray direction
        // use cosine-weighted hemisphere sampling
        vec2 uv = vec2(rnd1, rnd2);
        vec3 rayDirection = to_tangent_space(cosine_sample_hemisphere(uv.x, uv.y), surfelN);

        // ray length
        float tMin = 0.00001;
        float tMax = 100000.0;

        #ifdef ENABLE_SURFEL_RADIAL_DEPTH
        // radial depth function
        uint2 radialDepthPixel = uint2(compute_surfel_octmap_pixel(currentSurfelID, rayDirection, SURFEL_DEPTH_TEXELS));
        #endif

        // trace
        bool hit = traceScene(rayOrigin, rayDirection, tMin, tMax);
        if (!hit) {
            #ifdef ENABLE_SURFEL_RADIAL_DEPTH
            // update surfel moments with surfel radius
            update_surfel_depth(radialDepthPixel, surfel.radius);
            #endif

            // get sky color
            vec3 env = sky.data.color;
            result += vec4(env, 1.0);
        }
        else {
            #ifdef ENABLE_SURFEL_RADIAL_DEPTH
            // update surfel moments with surfel radius
            float hitDepth = hitData.distance;
            if (hitDepth < surfel.radius) {
                hitDepth *= 0.8;
            }
            update_surfel_depth(radialDepthPixel, hitDepth);
            #endif

            // record hit information
            HitInfo surface;
            surface.position = hitData.position;
            surface.normal = hitData.normal;
            surface.albedo = hitData.albedo;
            surface.emissive = hitData.emissive;
            surface.distance = hitData.distance;

            // irradiance information
            vec3 hitResult = vec3(0.0);

            // light sampling
            for (uint i = 0; i < info.lightCount; i++) {
                LightInfo light = lights.data[i];

                // lighting info
                float NoL = -1.0;
                float dist = -1.0;
                vec3 lightDiffuse = vec3(0.0);

                switch (light.type) {
                    // compute direct point lighting
                    case LIGHT_TYPE_POINT:
                        lightDiffuse = compute_point_lighting(light, surface, NoL, dist);
                        break;
                    // compute direct spot lighting
                    case LIGHT_TYPE_SPOTLIGHT:
                        lightDiffuse = compute_spot_lighting(light, surface, NoL, dist);
                        break;
                    // compute direct directional lighting
                    case LIGHT_TYPE_DIRECTIONAL:
                        lightDiffuse = compute_directional_lighting(light, surface, NoL, dist);
                        break;
                }

                // add light contribution
                if (NoL > 0.0 && dist > 0.0) {
                    // ray information at hit location
                    rayOrigin = surface.position + surface.normal * 0.00001;

                    // check occlusion
                    if (traceShadow(rayOrigin, rayDirection, tMin, dist)) {
                        hitResult += lightDiffuse / PI;
                    }
                }
            }

            // infinite bounces
            vec4 surfelGI = compute_surfel_lighting(camera.data, surface.position, surface.normal);
            if (surfelGI.a > 0.0) {
                surfelGI.rgb /= surfelGI.a;
                surfelGI.a = clamp(surfelGI.a, 0.0, 1.0);
                hitResult += surfelGI.rgb;
            }

            // adding to final result
            hitResult *= surface.albedo;
            hitResult += surface.emissive;
            result += vec4(hitResult, 1.0);
        }
        // end of scene ray trace
    }

    // surfel irradiance sharing
    #if 1
    vec4 surfelGI = compute_irradiance_sharing(camera.data, surfelP, surfelN, data.variance);
    if (surfelGI.a > 0.0) {
        surfelGI.rgb /= surfelGI.a;
        surfelGI.a = clamp(surfelGI.a, 0.0, 1.0);
        result += surfelGI;
    }
    #endif

    // apply moving average integrator
    if (result.a > 0.0) {
        result /= result.a;
        multiscale_mean_estimator(result.rgb, data, 0.08);
    }

    // update surfel life
    data.life++;

    surfelData.data[liveSurfelID] = data;
}
