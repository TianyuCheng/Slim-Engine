#version 450
#extension GL_ARB_separate_shader_objects                : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable

#define ENABLE_SURFEL_DEBUG_POINT
/* #define ENABLE_SURFEL_DEBUG_RANDOM */

#include "pack.h"
#include "unpack.h"
#include "camera.h"
#include "random.h"
#include "colors.h"
#include "../common.h"

layout(local_size_x = SURFEL_TILE_X,
       local_size_y = SURFEL_TILE_Y,
       local_size_z = 1) in;

// frame information
layout(set = 0, binding = SCENE_FRAME_BINDING) uniform
Frame { FrameInfo data; } frame;

// camera information
layout(set = 0, binding = SCENE_CAMERA_BINDING) uniform
Camera { CameraInfo data; } camera;

// surfel information
layout(set = 1, binding = SURFEL_BINDING) buffer
SurfelBuffer { Surfel data[]; } surfels;

// surfel alive
layout(set = 1, binding = SURFEL_LIVE_BINDING) buffer
SurfelLiveBuffer { uint data[]; } surfelLive;

// surfel alive
layout(set = 1, binding = SURFEL_DATA_BINDING) buffer
SurfelDataBuffer { SurfelData data[]; } surfelData;

// surfel grids
layout(set = 1, binding = SURFEL_GRID_BINDING) buffer
SurfelGridBuffer { SurfelGridCell data[]; } surfelGrids;

// surfel cells
layout(set = 1, binding = SURFEL_CELL_BINDING) buffer
SurfelCellBuffer { uint data[]; } surfelCells;

// surfel stat
layout(set = 1, binding = SURFEL_STAT_BINDING) buffer
SurfelStatBuffer { SurfelStat data; } surfelStat;

// surfel coverage
layout(set = 1, binding = SURFEL_COVERAGE_BINDING, r32f) uniform
image2D coverageImage;

// surfel depth atlas texture
layout(set = 1, binding = SURFEL_DEPTH_BINDING, rg32f) uniform
image2D surfelDepth;

// gbuffer diffuse
layout(set = 2, binding = GBUFFER_DIFFUSE_BINDING, rgba32f) uniform
image2D diffuseImage;

// gbuffer depth
layout(set = 2, binding = GBUFFER_ALBEDO_BINDING) uniform
sampler2D albedoImage;

// gbuffer depth
layout(set = 2, binding = GBUFFER_DEPTH_BINDING) uniform
sampler2D depthImage;

// gbuffer object/instance
layout(set = 2, binding = GBUFFER_OBJECT_BINDING) uniform
usampler2D objectImage;

// gbuffer normal
layout(set = 2, binding = GBUFFER_NORMAL_BINDING) uniform
sampler2D normalImage;

// debug surfel
layout(set = 3, binding = DEBUG_SURFEL_BINDING, rgba8) uniform
image2D debugImage;

// surfel variance
layout(set = 3, binding = DEBUG_SURFEL_VAR_BINDING, rgba8) uniform
image2D varianceImage;

shared uint groupMinSurfelID;
shared uint groupMinSurfelCoverage;

/**
 * This compute shader performs the following:
 * 1. compute coverage for each pixel
 * 2. iteratively spawn new surfel based based on low coverage
 * 3. recycle surfels on high coverage
 */
void main() {
    groupMinSurfelID = 0xffffffff;
    groupMinSurfelCoverage = 0xffffffff;
    memoryBarrierShared();

    int2 resolution = int2(frame.data.resolution);

    // dimension check
    int2 pixel = int2(gl_GlobalInvocationID.xy);
    if (any(greaterThanEqual(pixel, resolution))) {
        return;
    }

    // calculate basic information
    float depth  = texelFetch(depthImage,  pixel, 0).x;
    uint  primID = texelFetch(objectImage, pixel, 0).x;
    vec3  N      = texelFetch(normalImage, pixel, 0).xyz;
    vec2  uv     = (vec2(pixel) + vec2(0.5)) / vec2(resolution);
    vec3  P      = compute_world_position(uv, depth, camera.data.invVP);

    // fetch surfel grid
    int3 gridIndex = compute_surfel_grid(camera.data, P);
    uint cellIndex = compute_surfel_cell(gridIndex);
    SurfelGridCell cell = surfelGrids.data[cellIndex];

    float coverage = 0.0;
    vec4 color = vec4(0.0);
    vec4 debug = vec4(0.0);
    vec4 variance = vec4(0.0);
    vec4 shortMean = vec4(0.0);
    float vbbr = 0.0;
    float inconsistency = 0.0;

    // iterate through all surfels in this grid cell
    for (uint i = cell.offset; i < cell.offset + cell.count; i++) {
        uint cellIndex = surfelCells.data[i];
        Surfel surfel = surfels.data[cellIndex];
        SurfelData sdata = surfelData.data[surfelLive.data[cellIndex]];

        // apply surfel coverage
        vec3 L = surfel.position - P;
        float d2 = dot(L, L);
        float r2 = surfel.radius * surfel.radius;

        if (d2 < r2) {
            vec3 surfelN = unpack_unitvec3(surfel.normal) * 2.0 - 1.0;
            float dotN = dot(surfelN, N);
            if (dotN > 0) {
                float dist = sqrt(d2);
                float contribution = 1.0;
                contribution *= clamp(dotN, 0.0, 1.0);
                contribution *= clamp(1.0 - dist / surfel.radius, 0.0, 1.0);

                #ifdef ENABLE_SURFEL_RADIAL_DEPTH
                // radial depth function
                uint2 radialDepthPixel = uint2(compute_surfel_octmap_pixel(cellIndex, L/dist, SURFEL_DEPTH_TEXELS));
                vec2 radialDepth = imageLoad(surfelDepth, int2(radialDepthPixel)).xy;
                contribution *= compute_surfel_radial_depth(radialDepth, dist);
                #endif

                // surfel moment helps prevent incorrect color bleeding.
                contribution = smoothstep(0.0, 1.0, contribution);
                coverage += contribution;
                color += vec4(surfel.color, 1.0) * contribution;
                #ifdef ENABLE_SURFEL_DEBUG_RANDOM
                debug += vec4(random_colors[cellIndex % random_color_count], 1.0) * contribution;
                #endif

                // for spawning a new surfel
                variance += vec4(sdata.variance, 1.0) * contribution;
                shortMean += vec4(sdata.shortMean, 1.0) * contribution;
                vbbr += sdata.vbbr * contribution;
                inconsistency += sdata.inconsistency * contribution;
            }
        }
        #ifdef ENABLE_SURFEL_DEBUG_POINT
        if (d2 < 0.0025) {
            debug += vec4(random_colors[cellIndex % random_color_count], 1.0);
        }
        #endif
        // end of pixel coverage check
    }

    // normalize color
    if (color.a > 0.0) {
        color.rgb /= color.a;
        color.a = clamp(color.a, 0.0, 1.0);
    }
    color.a = 1.0;

    // normalize debug color
    if (debug.a > 0.0) {
        debug.rgb /= debug.a;
        debug.a = clamp(debug.a, 0.0, 1.0);
    }

    // normalize variance
    if (variance.a > 0.0) {
        vbbr /= variance.a;
        inconsistency /= variance.a;
        shortMean /= variance.a;
        variance /= variance.a;
    }

    // output
    imageStore(debugImage, pixel, debug);
    imageStore(diffuseImage, pixel, color);
    imageStore(coverageImage, pixel, vec4(coverage, coverage, coverage, 1.0));
    imageStore(varianceImage, pixel, vec4(variance.r, 0.0, 1.0 - variance.r, 1.0));

    // spawn new surfels based on coverage
    if (surfelStat.data.pause != 0) {
        return;
    }

    // rng state
    RNGState rng = init_rng(uint2(pixel), resolution, frame.data.frameID);

    // find minimum surfel coverage
    uint2 localID = gl_LocalInvocationID.xy;
    uint covU32 = uint(coverage * 255.0);
    uint coverageID = (covU32          & 0xff  ) << 24 // top bits matters the most
                    | (uint(rand(rng)) & 0xffff) << 8  // shuffles pixels around
                    | (     localID.x  & 0xf   ) << 4
                    | (     localID.y  & 0xf   ) << 0;
    if (cell.count < SURFEL_CELL_CAPACITY) {
        atomicMin(groupMinSurfelID, coverageID);
        atomicMin(groupMinSurfelCoverage, covU32);

        memoryBarrierShared();

        // spawn surfel
        if (depth < 1.0 && coverageID == groupMinSurfelID && coverage < SURFEL_LOW_COVERAGE) {
            // need to spawn a new surfel
            float zNear = camera.data.zNear;
            float zFar = camera.data.zFar;
            float zFarRcp = camera.data.zFarRcp;
            float linear = linearize_depth(depth, zNear, zFar) * zFarRcp;

            float threshold = pow(1.0 - linear, 1.0);
            float chance = rand(rng);

            // stochastically spawn surfel
            if (chance > threshold) {
                // request an available surfel
                uint availableSurfelID = atomicAdd(surfelStat.data.count, 1);
                uint surfelID = surfelLive.data[availableSurfelID];

                // allocate new surfel
                SurfelData data;
                data.position = P;
                data.normal = pack_unitvec3(N * 0.5 + 0.5);
                data.life = 0;
                data.recycle = 0;
                data.vbbr = vbbr;
                data.inconsistency = inconsistency;
                data.mean = color.rgb;
                data.shortMean = shortMean.rgb;
                data.variance = variance.xyz;
                data.instanceID = primID;
                data.surfelID = surfelID;

                surfelData.data[surfelID] = data;
            }
        }
    }
}
